"""
Задача: пошаговое управление инвестиционным портфелем
Метод решения: динамическое программирование, критерий Байеса

Предполагаем упрощённую модель:
- В начале каждого этапа весь капитал можно мгновенно переложить
  в один из трёх активов (ЦБ1, ЦБ2 или депозиты).
- Комиссии и шаги по 25% игнорируем, чтобы сконцентрироваться на DP.
- Цель: максимизировать математическое ожидание капитала после 3-го этапа.
"""

from pprint import pprint

# 1. Исходные данные

# Начальный капитал (сумма всех бумаг, депозита и свободных средств)
X0 = 100 + 800 + 400 + 600  # 1900

# Состояния экономики
states = ["good", "neutral", "bad"]  # благоприятная, нейтральная, негативная

# Вероятности для каждого этапа (в том же порядке, что и states)
# p_t[state_index]
probabilities = {
    1: [0.60, 0.30, 0.10],
    2: [0.30, 0.20, 0.50],
    3: [0.40, 0.40, 0.20],
}

# Коэффициенты изменения стоимости a_{t, i}(state)
# Структура: returns[t][asset_name][state_index]
# asset_name ∈ {"CB1", "CB2", "DEP"}

returns = {
    1: {  # этап 1
        "CB1": [1.20, 1.05, 0.80],
        "CB2": [1.10, 1.02, 0.95],
        "DEP": [1.07, 1.03, 1.00],
    },
    2: {  # этап 2
        "CB1": [1.40, 1.05, 0.60],
        "CB2": [1.15, 1.00, 0.90],
        "DEP": [1.01, 1.00, 1.00],
    },
    3: {  # этап 3
        "CB1": [1.15, 1.05, 0.70],
        "CB2": [1.12, 1.01, 0.94],
        "DEP": [1.05, 1.01, 1.00],
    },
}

assets = ["CB1", "CB2", "DEP"]

# 2. Функция для вычисления ожидаемого мультипликатора μ_{t,i}

def expected_multiplier(t: int, asset: str) -> float:
    """
    Возвращает математическое ожидание коэффициента доходности
    для заданного этапа t и актива asset.

    μ_{t,i} = sum_s p_t(s) * a_{t,i}(s)
    """
    ps = probabilities[t]
    rs = returns[t][asset]

    # Скалярное произведение двух списков: сумма p_k * a_k
    mu = sum(p * r for p, r in zip(ps, rs))
    return mu


# Посчитаем все μ_{t,i} и выведем таблицу
mu = {t: {} for t in [1, 2, 3]}
for t in [1, 2, 3]:
    for asset in assets:
        mu[t][asset] = expected_multiplier(t, asset)

print("Ожидаемые мультипликаторы μ_{t,i}:")
pprint(mu)
print()

# 3. Динамическое программирование (уравнение Беллмана)

# best_factor[t] — это коэффициент k_t в записи V_t(x) = k_t * x
best_factor = {4: 1.0}  # после 3-го этапа будущих доходов нет
best_asset = {}  # оптимальный актив на каждом этапе

# Идём назад по времени: t = 3, 2, 1
for t in [3, 2, 1]:
    # Для каждого возможного актива считаем "кандидата" на k_t:
    # k_t_candidate(asset) = μ_{t,asset} * k_{t+1}
    candidates = {}
    for asset in assets:
        candidates[asset] = mu[t][asset] * best_factor[t + 1]

    # Выбираем максимум по активам
    # max_asset — актив с максимальным значением кандидата
    max_asset = max(candidates, key=candidates.get)
    max_value = candidates[max_asset]

    best_factor[t] = max_value
    best_asset[t] = max_asset

print("Коэффициенты k_t (V_t(x) = k_t * x):")
pprint(best_factor)
print()

print("Оптимальный актив на каждом этапе:")
for t in [1, 2, 3]:
    print(f"Этап {t}: вложить капитал в {best_asset[t]}")
print()

# 4. Итоговый ожидаемый доход при оптимальной стратегии

expected_final_capital = best_factor[1] * X0
expected_profit = expected_final_capital - X0

print(f"Начальный капитал: {X0:.2f}")
print(f"Ожидаемый капитал после 3-го этапа: {expected_final_capital:.2f}")
print(f"Ожидаемый доход: {expected_profit:.2f}")